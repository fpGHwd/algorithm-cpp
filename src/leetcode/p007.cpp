//
// Created by suzumiya on 4/30/19.
//

#include <iostream>
#include <vector>
#include <string>
#include <stack>

using namespace std;

/**
 * 以后每做一道题要写序列化流程：应用我的序列化。序列化和数字关系紧密（比如分条的思维，序号就是数字）
 * 什么都是数字才是最重要的。 如果没有到那一点，一定是没有到序列化中间那一个很小很关键的点。 - 通过序列化的联系（序列化其实就是联系的代名词？我好想忽略了)
 * 类似拼图，如果没有把已知的图片显式（拼上去）的话，很难找到关键的点。 比如写字也是啊。 不一定要写字，但是要做。
 *
 * 数字
 * 数字本身的范围int
 * 中间的转换 while循环（伪代码也基本是这种形式了。）
 * 反转数字的范围int
 * 反转数字
 */


// 如果说写这些文字也是一种纠缠于细节的话。纠缠与细节就是不能找到关键的地方，或者没有把时间放在关键的地方。关键的地方就是理解这个地方出现的数字。
// 广度就是数字，深度就是抽象。。。哎还是自己没有弄清楚概念。比如逻辑学的概念。
// 数字在纵向和横向的，以及所有方向都可以在概念上放大，缩小。。。所以数学思维很重要啊。

// 很多东西没有公式，无非是不能简单用公式，比如这个反转关系。（写了好多废话）

// 然后题解只是一种形式。所以不要纠结，中间的思维过程才是重要的。
// 他们用其他的算法时空来换，我用强转来换又有什么区别呢。无非都是时空而以。

class Solution {
public:
    int reverse(int x){
        bool neg = false;
        long m = x, r = 0;
        if(m < 0){
            neg = true;
            m = -m;
        }
        while(m >0){
            r = r*10 + m%10;
            m /=10;
        }
        if(neg)r=-r;
        if(r <= INT32_MAX && r >= INT32_MIN){
            return (int)r;
        }else{
            return 0;
        }
    }
};

// 数字转字符串然后再反转。如果有数字则可以判断大小。
// 然后把超过大小的数字判别出来。都是一样的序列化。
// 字符反转的计算公式

int main(int argc, char **argv) {
    return 0;
}